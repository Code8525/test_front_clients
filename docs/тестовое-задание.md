# Тестовое задание: раздел «Клиенты»

**Цель:** проверить умение разрабатывать типичный сценарий backoffice (список + фильтры с разными типами селектов + форма создания/редактирования) в стиле текущего проекта.

---

## Контекст

Нужно сделать раздел **«Клиенты»**: справочник клиентов с поиском, фильтрацией (в том числе с тремя типами селектов) и CRUD. Реализовать в виде фичи в структуре, похожей на существующие (например, `clients`, `inspection-points`).

---

## Что нужно сделать

### 1. Модель данных

**Клиент** (Client):

| Поле (API camelCase) | Тип | Описание |
|------------------------|-----|----------|
| `id` | string (uuid) | Идентификатор |
| `name` | string | Название / краткое имя |
| `fullName` | string \| null | Полное наименование |
| `partyType` | string | Тип стороны: `INDIVIDUAL` \| `LEGAL` |
| `inn` | string \| null | ИНН |
| `createdAt` | string (ISO date) | Дата создания |
| `updatedAt` | string (ISO date) | Дата обновления |
| `regionId` | string \| null | (опционально) Регион — для фильтра «Регион» (кеш-селект) |
| `clientId` | string \| null | (опционально) Родительский клиент — для фильтра «Родительский клиент» (селект «каждый раз») |

Поля `regionId` и `clientId` нужны для фильтров; в форме создания/редактирования их можно не показывать или добавить по желанию.

### 2. Функциональность

- **Список клиентов** — таблица с колонками: название, полное имя, тип стороны, ИНН, даты создания/обновления. Пагинация (limit/offset), сортировка хотя бы по одной колонке.
- **Фильтры** — обязательно реализовать:
  1. **Поле поиска (query)** — текстовый запрос: при нажатии «Искать» или по Enter передаётся в API как параметр поиска (например, по имени, ИНН, полному имени).
  2. **Три селекта** (все должны участвовать в запросе к API при применении фильтров):

     | Тип селекта | Название в фильтре | Значения / источник |
     |-------------|--------------------|----------------------|
     | **Грузится с бэка каждый раз** | **Родительский клиент** | При каждом открытии — запрос списка клиентов с API (актуальный список для выбора «головной» организации). Параметр фильтра, например: `clientId`. |
     | **С кешем** | **Регион** | Справочник регионов: один раз запрос к API (или при первом открытии), дальше опции из кеша. Параметр фильтра, например: `regionId`. |
     | **Статичный** | **Тип стороны** | Варианты в коде (enum + meta): «Физ. лицо» (`INDIVIDUAL`), «Юр. лицо» (`LEGAL`). Без запросов к API. Параметр фильтра: `partyType`. |
- **Создание клиента** — модальное окно с формой: название, полное имя, тип стороны (статичный селект), ИНН. Валидация: обязательные поля, при необходимости — формат ИНН.
- **Форма редактирования клиента** — обязательна. Модальное окно открывается по кнопке «Редактировать» в строке таблицы. Поля те же, что при создании: название, полное имя, тип стороны (статичный селект), ИНН. При открытии форма подставляется данными выбранного клиента (запрос по `id` или данные из списка). Валидация та же. После сохранения — обновление строки в таблице или перезапрос списка.
- **Удаление** — по желанию (кнопка в строке + подтверждение). Если не делаете — укажите в README.

Бэкенд — **отдельное FastAPI-приложение**, к которому фронт ходит по HTTP. Эндпоинты: список клиентов (с фильтрами, пагинацией, сортировкой), CRUD клиента, список клиентов для селекта «Родительский клиент» (при каждом открытии), справочник регионов для селекта «Регион» (для кеша на фронте). Контракт API (пути, параметры, форматы запросов/ответов) согласуется между фронтом и бэком.

### 3. Технические требования

- **Стек:** React, TypeScript, MUI (Material UI). Остальное — на ваш выбор (Zustand, React Hook Form и т.д.), желательно не усложнять без необходимости.
- **Структура:** одна фича в духе текущего проекта. Ожидаемая архитектура папок:

  **Фича (например, `src/features/clients/`):**

  ```
  src/features/clients/
  ├── components/           # UI компоненты фичи
  │   ├── forms/            # модалки с формами
  │   │   ├── clients-create-modal.tsx
  │   │   └── clients-edit-modal.tsx
  │   ├── clients-filters.tsx
  │   └── clients-table.tsx
  ├── pages/
  │   └── clients-page.tsx   # страница раздела
  ├── services/             # API и типы запросов/ответов
  │   ├── clients-api.ts    # вызовы API (FastAPI)
  │   ├── clients-requests.ts
  │   └── clients-responses.ts
  ├── store/
  │   └── index.ts          # объединённый store (реализация на усмотрение разработчика)
  └── types/
      ├── client-types.ts   # Client, PartyType и т.д.
      └── party-type-meta.tsx   # meta для статичного селекта (enum + label/icon)
  ```

- **Вопросы для разработчика (store):**
  - Как другие компоненты будут получать обновления из store (подписка на slice, селекторы, контекст)?
  - Какой вариант вы считаете оптимальным для данной фичи и почему?
  - *Рекомендация:* подписка только на нужные части состояния (селекторы) и обновление списка после create/edit (перезапрос или точечное обновление строки) — минимум лишних ре-рендеров и предсказуемый поток данных.

- **Типизация:** типы для клиента, для запросов (create/update) и ответов API.
- **Фильтры:** query + три типа селектов реализованы явно и используются в запросе списка клиентов.
- **Формы:** форма создания и **форма редактирования** (обе обязательны). Валидация одинаковая (React Hook Form + zod/yup или вручную — пустые/некорректные данные не отправляются).

---

## Критерии оценки

| Критерий | Что смотрим |
|----------|--------------|
| Структура кода | Разбиение на компоненты, сервисы, стор, типы |
| TypeScript | Корректные типы, без лишних `any` |
| Фильтры | Query + три селекта: «каждый раз», «кеш», «статичный» — все участвуют в запросе |
| Список | Таблица, пагинация, сортировка |
| Формы и валидация | Форма создания и форма редактирования, обязательные поля, проверка формата |
| Стиль и читаемость | Именование, форматирование |
| API (FastAPI) | Запросы к бэкенду: список клиентов, CRUD, опции селектов (клиенты, регионы) |

---

## Результат

1. **Код** — ссылка на репозиторий (GitHub/GitLab) или архив. В корне — **README**: как запустить фронт и бэкенд (FastAPI), что сделано, что не успели.
2. **Запуск** — в README команды для запуска фронта (`npm install`, `npm run dev` и т.п.) и отдельного FastAPI-бэкенда (например, `uvicorn`), чтобы проект собирался и работал с реальным API.

---
